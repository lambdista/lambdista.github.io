<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Alessandro Lacava]]></title>
  <link href="http://www.alessandrolacava.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.alessandrolacava.com/"/>
  <updated>2015-05-12T14:27:54+02:00</updated>
  <id>http://www.alessandrolacava.com/</id>
  <author>
    <name><![CDATA[Alessandro Lacava]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Brilliant Client/Server Apps With J2ME, PHP, and MySQL]]></title>
    <link href="http://www.alessandrolacava.com/blog/build-brilliant-clientserver-apps-with-j2me-php-and-mysql/"/>
    <updated>2011-10-26T16:53:41+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/build-brilliant-clientserver-apps-with-j2me-php-and-mysql</id>
    <content type="html"><![CDATA[<h3>In this article you&rsquo;ll see how to make the three technologies work together by developing a simple and useful application that lets you update a multi-user blog and download the latest posts from it.</h3>

<p>Write once, run anywhere. This Java motto seems to hold true even for mobile devices. Indeed, since it was born J2ME has had an ever-increasing impact on mobile development. Some may argue that J2ME is not as portable as other Java technologies, but even so, the result obtained on different mobile devices is, in most cases, still acceptable.</p>

<p>Go to <a href="http://www.devx.com/Java/Article/32069">DevX</a> to read the rest of the article: <strong>Build Brilliant Client/Server Apps with J2ME, PHP, and MySQL</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Obtaining Wireless News With J2ME and PHP]]></title>
    <link href="http://www.alessandrolacava.com/blog/obtaining-wireless-news-with-j2me-and-php/"/>
    <updated>2011-10-26T16:49:06+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/obtaining-wireless-news-with-j2me-and-php</id>
    <content type="html"><![CDATA[<h3>J2ME and PHP are both powerful technologies used to develop applications for mobile devices and Web applications, respectively. In this article, you&rsquo;ll see how to make them work together by developing a simple and useful application that retrieves the latest news from the Web and displays that on a mobile device.</h3>

<p>The Java 2 Platform, Micro Edition (J2ME) is targeted at cell phones, smart cards, pagers, and other consumer devices. J2ME technology consists of a virtual machine and a set of APIs suitable for tailored runtime environments for these devices. PHP, on the other hand, is a widely used server-based language to build Web applications. But these two radically different technologies work very well together. In this article you&rsquo;ll see how they can interact via HTTP (Hyper Text Transfer Protocol). Of course, this is not intended to be a thorough explanation of how HTTP works—you only need to know that HTTP is a request/response protocol. That simply means that the client application performs a request and the server application returns a response.</p>

<p>Go to <a href="http://www.devx.com/wireless/Article/28404">DevX</a> to read the rest of the article: <strong>Obtaining Wireless News with J2ME and PHP</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Split() of String | Multiple Whitespace Characters]]></title>
    <link href="http://www.alessandrolacava.com/blog/java-split-of-string-multiple-whitespace-characters/"/>
    <updated>2008-12-03T11:47:02+01:00</updated>
    <id>http://www.alessandrolacava.com/blog/java-split-of-string-multiple-whitespace-characters</id>
    <content type="html"><![CDATA[<p>The <code>split</code> method of the <code>String</code> class is very useful when you want to tokenize a string. Its power lies
in the fact that it accepts a string, as a parameter, which can be a regular expression. However you must
be careful when you want to split a string using the whitespace character as a delimiter. Consider the
following snippet of code:</p>

<pre><code class="java ">String str = "Testing split using two  whitespace characters";
String[] tokens = str.split("\\s");
for(String token : tokens) {
  System.out.println("-" + token + "-");
}
</code></pre>

<p>What&rsquo;s the output produced by the previous code? If you think it is the following one you&rsquo;re wrong:</p>

<ul>
<li>-Testing-</li>
<li>-split-</li>
<li>-using-</li>
<li>-two-</li>
<li>-whitespace-</li>
<li>-characters-</li>
</ul>


<p>The actual output is instead this one:</p>

<ul>
<li>-Testing-</li>
<li>-split-</li>
<li>-using-</li>
<li>-two-</li>
<li>&ndash;</li>
<li>-whitespace-</li>
<li>-characters-</li>
</ul>


<p>Where in the hell did that empty string come out from? It comes out from the two whitespace characters that
are between the word <strong>two</strong> and <strong>whitespace</strong> of the <strong>str</strong> string. If this is what you want OK. However,
most of the time, you will want to discard that empty string from your resulting string array. You can obtain this
result by using the <strong>\s+</strong> regex in place of <strong>\s</strong>. Basically, the previuos code becomes:</p>

<pre><code class="java">String str = "Testing split using two  whitespace characters";
String[] tokens = str.split("\\s+");
for(String token : tokens) {
  System.out.println("-" + token + "-");
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OutOfMemoryError In Eclipse | Java Virtual Machine (JVM)]]></title>
    <link href="http://www.alessandrolacava.com/blog/outofmemoryerror-in-eclipse-java-virtual-machine-jvm/"/>
    <updated>2008-07-22T10:53:07+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/outofmemoryerror-in-eclipse-java-virtual-machine-jvm</id>
    <content type="html"><![CDATA[<h1>OutOfMemoryError in Eclipse | Java Virtual Machine (JVM)</h1>

<p>It might happen that while running a Java application within the Eclipse environment you get an OutOfMemoryError due to the maximum amount of memory dedicated to the heap. You can fix it by increasing the minimum (-Xms parameter) and maximum (-Xmx parameter) heap size. You can do it in two different ways:</p>

<ol>
<li>By editing your <strong>eclipse.ini</strong> file you find under your Eclipse installation directory. Within that file you should find two lines similar to the following ones:</li>
</ol>


<p><strong>-Xms40m</strong>
<strong> -Xmx512m</strong></p>

<p>You might want to change them depending on your hardware. For example I changed them as follows:</p>

<p><strong>-Xms256m</strong>
<strong>-Xmx1024m</strong></p>

<p>It means: &ldquo;start with an initial heap size of 256 MB and grow to a maximum of 1024MB, that is 1GB.&rdquo;</p>

<ol>
<li>By editing the <strong>Run Configurations in Eclipse</strong>. To do this, right-click on the class you want to run (the one with the main method) and then select:</li>
</ol>


<p><strong>Run As -> Run Configurations</strong></p>

<p>Click on the <strong>Arguments</strong> tab. In the VM Arguments box type:</p>

<p><strong>-Xms256m -Xmx1024m</strong></p>

<p>or whatever you prefer, depending on the hardware you possess.</p>

<p><strong>IMPORTANT NOTE: It is strongly recommended that you make a backup copy of your eclipse.ini file before editing it in any way.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get the Number of Columns In a ResultSet In Java]]></title>
    <link href="http://www.alessandrolacava.com/blog/how-to-get-the-number-of-columns-in-a-resultset-in-java/"/>
    <updated>2007-12-12T11:32:31+01:00</updated>
    <id>http://www.alessandrolacava.com/blog/how-to-get-the-number-of-columns-in-a-resultset-in-java</id>
    <content type="html"><![CDATA[<p>In Java it is possible to retrieve the number of columns of a <code>ResultSet</code> dinamically, thanks to the <code>ResultSetMetaData</code>
class. Here&rsquo;s an example:</p>

<pre><code class="java  ">// Here you get the conn object. E.g.:
// Connection conn = DriverManager.getConnection(...);

Statement st = conn.createStatement();
ResultSet rs = st.executeQuery("SELECT * FROM your_table");
ResultSetMetaData rsmd = rs.getMetaData();
int numCols = rsmd.getColumnCount();
System.out.println("Number of columns in your_table: " + numCols);
</code></pre>

<p>The previous code retrieves and displays the number of columns of <code>your_table</code>.</p>
]]></content>
  </entry>
  
</feed>
