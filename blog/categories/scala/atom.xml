<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | Alessandro Lacava]]></title>
  <link href="http://www.alessandrolacava.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://www.alessandrolacava.com/"/>
  <updated>2015-10-23T17:57:33+02:00</updated>
  <id>http://www.alessandrolacava.com/</id>
  <author>
    <name><![CDATA[Alessandro Lacava]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scala: Seq, Map and Set as Functions]]></title>
    <link href="http://www.alessandrolacava.com/blog/scala-seq-map-and-set-as-functions/"/>
    <updated>2015-10-23T10:24:00+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/scala-seq-map-and-set-as-functions</id>
    <content type="html"><![CDATA[<p>Yesterday my mate asked me: &ldquo;I have a <code>List[String]</code> and a <code>Map[String, Int]</code> and I want
a <code>List[Int]</code> where its values are those of the <code>Map</code> whose keys match the <code>List[String]</code> elements,
maintaining the order. Should I use pattern matching?&rdquo;. I know, the sentence is a bit convoluted but the
code will make it clear, hopefully. Anyway, I replied: &ldquo;No, you don&rsquo;t need pattern matching, you just need this&rdquo;:</p>

<pre><code class="scala">scala&gt; val m = Map("a" -&gt; 1, "b" -&gt; 2, "c" -&gt; 3)
m: scala.collection.immutable.Map[String,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3)

scala&gt; val l = List("a", "c", "b")
l: List[String] = List(a, c, b)

scala&gt; l collect m
res0: List[Int] = List(1, 3, 2)
</code></pre>

<p>Hold on, how does it work? If you look at the definition of <code>collect</code> you&rsquo;ll see it accepts a
<code>PartialFunction</code>, instead I passed a <code>Map</code> to it.
Well, it turns out that <code>Map</code> <em>is</em> a <code>PartialFunction</code>.</p>

<p>Since this peculiarity surprised him I decided to write a small post showing how Scala&rsquo;s <code>Map</code>,
<code>List</code> (actually <code>Seq</code>) and <code>Set</code> can be viewed as functions.</p>

<p><a name="functions_vs_partial_functions"></a></p>

<h2>Before starting: functions vs partial functions</h2>

<p>In short, a function is a mapping <code>A =&gt; B</code> that relates each value of type <code>A</code> to a
value of type <code>B</code>&ndash;modulo <em>bottom</em>. <code>A</code> and <code>B</code> are called <em>domain</em> and <em>codomain</em>, respectively. If you&rsquo;re not a math
addict, roughly speaking, the domain is the set of all values that you can provide as input to your function,
while the codomain is the result of the function application to the input, that is your function output.<br/>
On the other hand a partial function from <code>A</code> to <code>B</code> is not defined for some inputs of type <code>A</code>. E.g.:</p>

<pre><code class="scala">// function
scala&gt; val abs: Double =&gt; Double = x =&gt; if (x &gt; 0) x else -x
abs: Double =&gt; Double = &lt;function1&gt;

scala&gt; abs(42)
res1: Double = 42.0

scala&gt; abs(-42)
res2: Double = 42.0

// partial function
scala&gt; val sqrt: PartialFunction[Double, Double] = {
     |   case x if x &gt;= 0 =&gt; math.sqrt(x)
     | }

scala&gt; sqrt(4)
res3: Double = 2.0

scala&gt; sqrt(-1)
scala.MatchError: -1.0 (of class java.lang.Double)
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:251)
  at $anonfun$1.applyOrElse(&lt;console&gt;:7)
  at $anonfun$1.applyOrElse(&lt;console&gt;:7)
  at scala.runtime.AbstractPartialFunction$mcDD$sp.apply$mcDD$sp(AbstractPartialFunction.scala:36)
  ... 33 elided
</code></pre>

<p>Note that the <code>PartialFunction</code> definition is the following:</p>

<pre><code class="scala">trait PartialFunction[-A, +B] extends (A) =&gt; B
</code></pre>

<p>That is a <code>PartialFunction</code> is a <code>Function</code> that will just <em>throw</em> for those inputs the partial function is not
defined at. So you can use a <code>PartialFunction</code> wherever a <code>Function</code> is expected. Just keep in mind you&rsquo;ll get
an exception for some input values.</p>

<h2>Seq[A] as PartialFunction[Int, A]</h2>

<p>Being <code>List</code> an indirect subclass of <code>collection.Seq</code> and given that the latter has the following definition, you
can see clearly that every <code>Seq[A]</code> is also a <code>PartialFunction[Int, A]</code>:</p>

<pre><code class="scala">trait Seq[+A] extends PartialFunction[Int, A] with ...
</code></pre>

<p>Here&rsquo;s an example:</p>

<pre><code class="scala">scala&gt; val xs = List("a", "c", "b")
l: List[String] = List(a, c, b)

scala&gt; val f1: PartialFunction[Int, String] = xs
f1: PartialFunction[Int,String] = List(a, c, b)

scala&gt; f1(0)
res4: String = a
</code></pre>

<p>Of course I could have used <code>xs</code> directly without the assignment to <code>f1</code>:</p>

<pre><code class="scala">scala&gt; xs(0)
res2: String = a
</code></pre>

<p>I assigned the list to <code>f1</code> just to emphasise the fact that it&rsquo;s a partial function. It corresponds to the
index-based lookup.</p>

<p><strong>Performance concern</strong>: Take into account tha the index-based lookup on <code>List</code> has an cost of <code>O(n)</code>. For this type
of access you may consider using a <code>Vector</code> which has constant-time access cost. Anyway this post is not about
performance concerns about the collection API so I won&rsquo;t dig into this topic.</p>

<h2>Map[A, B] as PartialFunction[A, B]</h2>

<p>If you look at the <code>Map</code> definition you&rsquo;ll see that it extends <code>MapLike</code> which, in turn, extends <code>PartialFunction</code>.
So you can use it as follows:</p>

<pre><code class="scala">scala&gt; val m = Map("a" -&gt; 1, "b" -&gt; 2, "c" -&gt; 3, "d" -&gt; 4)
m: scala.collection.immutable.Map[String,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3, d -&gt; 4)

scala&gt; val f2: PartialFunction[String, Int] = m
f2: PartialFunction[String,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3, d -&gt; 4)

scala&gt; f2("a")
res5: Int = 1
</code></pre>

<h2>Set[A] as A => Boolean</h2>

<p>Here&rsquo;s the definition of <code>Set</code>:</p>

<pre><code class="scala">trait Set[A] extends (A) =&gt; Boolean with ...
</code></pre>

<p>It, evidently, extends <code>A =&gt; Boolean</code> which, as you probably already know, is just syntactic sugar for the more
verbose <code>Function[A, Boolean]</code>. Example:</p>

<pre><code class="scala">scala&gt; val s = Set("a", "b", "c")
s: scala.collection.immutable.Set[String] = Set(a, b, c)

scala&gt; val f3: String =&gt; Boolean = s
f3: String =&gt; Boolean = Set(a, b, c)

scala&gt; f3("a")
res6: Boolean = true
</code></pre>

<p>So, for instance, you can use a set to filter a list:</p>

<pre><code class="scala">scala&gt; val xs = List("a", "c", "b")
xs: List[String] = List(a, c, b)

scala&gt; val s = Set("a", "b", "d")
s: scala.collection.immutable.Set[String] = Set(a, b, d)

scala&gt; xs filter s
res7: List[String] = List(a, b)
</code></pre>

<h2>Conclusions</h2>

<p>As a final consideration take into account that <code>Seq</code>s and <code>Map</code>s are partial functions while <code>Set</code> is a
function. Partial functions could introduce insidious bugs.
For instance, consider the very first example of this post.
If the <code>Map</code> didn&rsquo;t contain all the elements of the <code>List</code> and I used
the <code>map</code> method instead of <code>collect</code> I would introduce a bug:</p>

<pre><code class="scala">scala&gt; val xs = List("a", "b", "c", "d")
xs: List[String] = List(a, b, c, d)

scala&gt; val m = Map("a" -&gt; 1)
m: scala.collection.immutable.Map[String,Int] = Map(a -&gt; 1)

scala&gt; xs map m
java.util.NoSuchElementException: key not found: b
  at scala.collection.MapLike$class.default(MapLike.scala:228)
  at scala.collection.AbstractMap.default(Map.scala:59)
  at scala.collection.MapLike$class.apply(MapLike.scala:141)
  at scala.collection.AbstractMap.apply(Map.scala:59)
  at scala.collection.immutable.List.map(List.scala:277)
  ... 33 elided
</code></pre>

<p>This is because <code>map</code> accepts a function and providing a partial function instead you get the exception for not valid
inputs as I said in the <a href="#functions_vs_partial_functions">functions vs partial functions section</a>.</p>

<p>From now on, whenever you have a collection hanging around, consider looking at it as a
function. This could help to solve your problem without using pattern matching or other boilerplate.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Case Classes In Depth]]></title>
    <link href="http://www.alessandrolacava.com/blog/scala-case-classes-in-depth/"/>
    <updated>2015-05-22T08:12:07+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/scala-case-classes-in-depth</id>
    <content type="html"><![CDATA[<p>For this post I&rsquo;ll consider the following simple case class unless otherwise specified:
<code>scala
case class Person(lastname: String, firstname: String, birthYear: Int)
</code></p>

<h2>Common knowledge about case classes</h2>

<p>When you declare a case class the Scala compiler does the following for you:</p>

<ul>
<li>Creates a class and its companion object.</li>
<li>Implements the <code>apply</code> method that you can use as a factory. This lets you create
instances of the class without the <code>new</code> keyword. E.g.:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Lacava</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Alessandro</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1976</span><span class="o">)&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;//</span> <span class="n">instead</span> <span class="k">if</span> <span class="n">the</span> <span class="n">slightly</span> <span class="n">more</span> <span class="n">verbose</span><span class="k">:</span>
</span><span class='line'><span class="kt">val</span> <span class="kt">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Lacava</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Alessandro</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1976</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>Prefixes all arguments, in the parameter list, with <code>val</code>. This means the class is immutable, hence
you get the accessors but no mutators. E.g.:
<code>scala
val lastname = p.lastname
// the following won't compile:
p.lastname = "Brown"
</code></p></li>
<li><p>Adds <em>natural</em> implementations of <code>hashCode</code>, <code>equals</code> and <code>toString</code>. Since <code>==</code> in Scala always
delegates to equals, this means that case class instances are always compared structurally. E.g.:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">p_1</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Brown</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">John</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1969</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">p_2</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Lacava</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Alessandro</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1976</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">p</span> <span class="o">==</span> <span class="n">p_1</span> <span class="c1">// false</span>
</span><span class='line'><span class="n">p</span> <span class="o">==</span> <span class="n">p_2</span> <span class="c1">// true</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>Generates a <code>copy</code> method to your class to create other instances starting from another one and keeping
some arguments the same. E.g.: Create another instance keeping the <code>lastname</code> and changing <code>firstname</code>
and <code>birthYear</code>:
<code>scala
// the result is: Person(Lacava,Michele,1972), my brother :)
val p_3 = p.copy(firstname = "Michele", birthYear = 1972)
</code></p></li>
<li><p>Probably, most importantly, since the compiler implements the <code>unapply</code> method, a case class
supports pattern matching. This is especially important when you define an Algebraic Data Type (ADT). E.g.:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Value</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value:%20T&quot;</span><span class="o">&gt;</span><span class="n">T</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">NoValue</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Maybe</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">v_1</span><span class="k">:</span> <span class="kt">Maybe</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">NoValue</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">logValue</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;value:%20Maybe[T]&quot;</span><span class="o">&gt;</span><span class="n">T</span><span class="o">&lt;/</span><span class="n">a</span><span class="k">&gt;:</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="n">value</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Value</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;We have a value here: $v&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">NoValue</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">I</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span><span class="n">m</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">no</span> <span class="n">value</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">logValue</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="c1">// prints We have a value here: 42</span>
</span><span class='line'><span class="n">logValue</span><span class="o">(</span><span class="n">v_1</span><span class="o">)</span> <span class="c1">// prints I&amp;rsquo;m sorry, no value</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>As you probably already know, when your class has no argument you use a <code>case object</code>
instead of a <code>case class</code> with an empty parameter list.</p>

<p>Apart from being used in pattern matching the <code>unapply</code> method lets you <em>deconstruct</em> a case class to extract
it&rsquo;s fields, both during pattern matching and as a simple expression to extract some of its fields. E.g.:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="nc">Person</span><span class="o">(</span><span class="n">lastname</span><span class="o">,</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;,</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;)</span> <span class="k">=</span> <span class="n">p</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">println</span><span class="o">(</span><span class="n">lastname</span><span class="o">)</span> <span class="c1">// prints Lacava</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2><em>Not so common</em> knowledge about case classes</h2>

<ul>
<li>What if you need a function that, given your case class arguments as parameters, creates an instance of the class?
Here&rsquo;s how you can do it by partially applying <code>apply</code> (no pun intended :)):
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">personCreator</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Person</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">apply</span> <span class="k">_</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;//</span> <span class="n">the</span> <span class="n">result</span> <span class="n">is</span><span class="k">:</span> <span class="kt">Person</span><span class="o">(</span><span class="kt">Brown</span><span class="o">,</span><span class="kt">John</span><span class="o">,</span><span class="mi">1969</span><span class="o">)</span>
</span><span class='line'><span class="n">personCreator</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Brown</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">John</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1969</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>What if you want your function, from the previous point, to be curried? Enters the <code>curried</code> method:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">curriedPerson</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Person</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">curried</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">lacavaBuilder</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Person</span> <span class="k">=</span> <span class="n">curriedPerson</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Lacava</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">me</span> <span class="k">=</span> <span class="n">lacavaBuilder</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Alessandro</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)(</span><span class="mi">1976</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">myBrother</span> <span class="k">=</span> <span class="n">lacavaBuilder</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Michele</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)(</span><span class="mi">1972</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>What about obtaining a function that accepts a tuple whose arity is equal to the number of the case class
arguments, and produces an instance of the class? Well, there&rsquo;s the <code>tupled</code> method for that:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">tupledPerson</span><span class="k">:</span> <span class="o">((</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Person</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">tupled</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">meAsTuple</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Lacava</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">Alessandro</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="mi">1976</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">meAsPersonAgain</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="n">tupledPerson</span><span class="o">(</span><span class="n">meAsTuple</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>You could also need a function that, given an instance of your class as input, produces an
<code>Option[TupleN[A1, A2, ..., AN]]</code> as output, where <code>N</code> is the number of the case class arguments and
<code>A1, A2, ..., AN</code> are their types. E.g.:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">toOptionOfTuple</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">unapply</span> <span class="k">_</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="n">toOptionOfTuple</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="c1">// Some((Lacava,Alessandro,1976))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The <code>curried</code> and <code>tupled</code> methods are inherited from <code>AbstractFunctionN</code> which is extended by the autogenerated
companion object. <code>N</code> is the number of the case class formal parameters.
Note that, of course, if <code>N = 1</code> you won&rsquo;t get <code>curried</code> and <code>tupled</code> because
they wouldn&rsquo;t make sense for just one parameter!</p>

<h2>Defining a case class using the <em>curried</em> form</h2>

<p>There&rsquo;s another less-known way of defining a case class, e.g.:</p>

<pre><code class="scala">
case class Keyword(text: String)(source: String, foo: Int)
</code></pre>

<p>The formal parameters in the first parameter section of a case class (just <code>text</code> in this case) are called <em>elements</em>;
they are treated specially. All the goodies you get when you define a case class (accessors, pattern matching support,
copy method, &hellip;) only apply to the first section. For example you don&rsquo;t have an accessor for <code>source</code> since
the compiler didn&rsquo;t implicitly prefix it with <code>val</code>, like it did for <code>text</code> instead. E.g.:</p>

<pre><code class="scala">val k1 = Keyword("restaurant")("storage", 1)

// won't compile
val source = k1.source
</code></pre>

<p>You can solve the accessor problem by prefixing the parameters with <code>val</code>. E.g.:</p>

<pre><code class="scala">case class Keyword(text: String)(val source: String, val foo: Int)
</code></pre>

<p>Anyway you still won&rsquo;t get all the other case class features.
For instance, you cannot use the <code>copy</code> method by specifying only the <code>source</code> parameter. You have to specify, at least, all the parameters
of the sections successive to the first. E.g.:</p>

<pre><code class="scala">// won't compile
val k2 = k1.copy()(source = "web")

// will compile
val k3 = k1.copy()(source = "web", foo = 1)
</code></pre>

<p>Finally, the companion object of a case class defined in such a way won&rsquo;t extend <code>AbstractFunctionN</code>, so the <code>tupled</code>
and <code>curried</code> methods are not available.</p>

<p>At this point the natural question that may arise is: &ldquo;Why on earth should I want to define a case class in such a way?&rdquo;
Apparently there are cases when it could be a <em>reasonable</em> choice. For example suppose that, for your business model,
two instances of <code>Keyword</code> are to be considered equal iff they have the same <code>text</code> field. Well, in such a case by defining the
case class using the <em>curried</em> form you&rsquo;ll get what you want. E.g.:</p>

<pre><code class="scala">val k1 = Keyword("restaurant")("storage", 1)
val k2 = Keyword("restaurant")("web", 2)

k1 == k2 // true!
</code></pre>

<p>That&rsquo;s because also the <code>equals</code> implementation, you get for free for case classes, only applies to the first
parameter section, so only to <code>text</code> in this case. I&rsquo;m not saying here that this is always the best choice
but it could be of help in certain situations.</p>

<p>In fact, you could define your case class as usual and override <code>equals</code> on your own. However overriding
<code>equals</code> is not very trivial. Indeed, before doing that
I recommend you read the <a name="programmingInScala"></a>chapter 30 of
<strong>Programming in Scala: A Comprehensive Step-by-Step Guide,
2nd Edition - Odersky, Spoon, Venners</strong>. Its title is
<strong>Object Equality</strong> and it&rsquo;s just 25 pages long!</p>

<h2>For the most curious ones</h2>

<p>Furthermore, since each case class extends the <code>Product</code> trait it inherits the following methods:</p>

<ul>
<li><code>def productArity: Int</code>, returns the size of this product. In this case it corresponds to the number of arguments in the
case class. E.g.:</li>
</ul>


<pre><code class="scala">val p = Person("Lacava", "Alessandro", 1976)

val arity = p.productArity // equals to 3
</code></pre>

<ul>
<li><p><code>def productElement(n: Int): Any</code>, returns the n-th element of this product, 0-based. In this case it corresponds to
the n-th argument of the class. E.g.:
<code>scala
val lastname: Any = p.productElement(0) // Lacava
</code></p></li>
<li><p><code>def productIterator: Iterator[Any]</code>, returns an iterator over all the elements of this product which,
in the case class context, they are its arguments.</p></li>
<li><p><code>def productPrefix: String</code>, returns a string used in the <code>toString</code> method of the derived classes.
In this case it&rsquo;s the name of the class. E.g.:
<code>scala
val className: String = p.productPrefix // the result is Person
</code></p></li>
</ul>


<h2>Final Notes</h2>

<ul>
<li><p>I used type declarations in many expressions just to make things clearer. Of course I could have left them out
and let the type inferer do its job.</p></li>
<li><p>Some <code>Product</code>&rsquo;s methods return <em>Any-based</em> types, namely <code>productElement</code> and <code>productIterator</code>. For example,
<code>p.productElement(0)</code> returns the <code>lastname</code> but it is of type <code>Any</code> so if you need to use it as <code>String</code> you have to
cast it, which is an operation you should strive to avoid as much as possible.</p></li>
<li><p><code>Product</code> extends <code>Equals</code> so every case class also inherits the <code>canEqual</code> method but, of course,
going into its details is not the scope of this post. Besides, you don&rsquo;t have to worry about it because it&rsquo;s
used interally by the autogenerated <code>equals</code> method, unless you decide to implement your own version of <code>equals</code>
in which case you need to take into account <code>canEqual</code>. Again, in such a case I strongly suggest you read the
chapter cited <a href="#programmingInScala">here</a>.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala's Self-recursive Types]]></title>
    <link href="http://www.alessandrolacava.com/blog/scala-self-recursive-types/"/>
    <updated>2015-03-30T14:59:24+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/scala-self-recursive-types</id>
    <content type="html"><![CDATA[<p>One of the advantages of using a statically typed language is that you can use the type system to enforce
some constraints. Scala provides <em>self-recursive types</em>, aka <em>F-bounded polymorphic types</em>
that&ndash;along with <em>self types</em>&ndash;let you put powerful constraint to your type definitions.</p>

<h2>Self-recursive type definition</h2>

<p>Terminology apart, let me show you one of the use cases where this could be useful. Consider the following example
which does not use a self-recursive type:</p>

<pre><code class="scala">trait Doubler[T] {
  def double: T
}
</code></pre>

<pre><code class="scala">case class Square(base: Double) extends Doubler[Square] {
  override def double: Square = Square(base * 2)
}
</code></pre>

<p>So far so good, the compiler will not complain. The problem is that it won&rsquo;t complain even if you write
something outrageous like the following code:</p>

<pre><code class="scala">case class Person(firstname: String, lastname: String, age: Int)

case class Square(base: Double) extends Doubler[Person] {
  override def double: Person = Person("John", "Smith", 42)
}
</code></pre>

<p>You want to avoid something like that by enforcing a compile-time check. Enters a self-recursive type:</p>

<pre><code class="scala">trait Doubler[T &lt;: Doubler[T]] {
  def double: T
}   
</code></pre>

<p>By using this definition of <code>Doubler</code> you&rsquo;re saying: &ldquo;Hey, if someone tries to extends <code>Doubler</code> with a type
which doesn&rsquo;t extend <code>Doubler</code> in turn (hence <em>self-recursive</em>), do not compile it&rdquo;.
In this case the previous definition of <code>Square</code>, which extends <code>Doubler[Person]</code>, doesn&rsquo;t compile.</p>

<p>Note that self-recursive types are not specific to Scala. Indeed Java uses them too.
Take, for example, the <code>Enum</code> definition:</p>

<pre><code class="java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable {
...
}
</code></pre>

<p><code>E extends Enum&lt;E&gt;</code> in <em>Javanese</em> means exactly <code>E &lt;: Enum[E]</code></p>

<h2>Self type definition</h2>

<p>F-bounded polymorphic types are of great help but sometimes they are not enough to enforce the constraints you need.
Indeed, the previous definition of <code>Doubler</code> has still one problem. Consider the next code:</p>

<pre><code class="scala">trait Doubler[T &lt;: Doubler[T]] {
  def double: T
}

case class Square(base: Double) extends Doubler[Square] {
  override def double: Square = Square(base * 2)
}

case class Apple(kind: String) extends Doubler[Square] {
  override def double: Square = Square(5)
}
</code></pre>

<p>Can you spot the problem? Look at the <code>Apple</code> definition, it extends <code>Doubler[Square]</code> instead of <code>Doubler[Apple]</code>.</p>

<p>This code compiles because it respects the constraint put by the <code>Doubler</code> definition.
Indeed <code>Square</code> extends <code>Doubler</code> so it can be used in <code>Apple</code>. Sometimes this is what you want in which case
the self-recursive type will do. In cases when you donâ€™t want this to happen a self type can work this out:</p>

<pre><code class="scala">trait Doubler[T &lt;: Doubler[T]] { self: T =&gt;
  def double: T
}
</code></pre>

<p>Now if you try to compile the previous definition of <code>Apple</code> the compiler will complain by saying something like:</p>

<pre><code class="scala">error: illegal inheritance;
 self-type Apple does not conform to Doubler[Square]'s selftype Square
       case class Apple(kind: String) extends Doubler[Square] {
                                              ^
</code></pre>

<h2>Conclusions</h2>

<p>If you&rsquo;re thinking: &ldquo;Come on! I would never extend <code>Apple</code> that way because I know what I meant when I wrote
my <code>Doubler</code> abstraction. I don&rsquo;t need then the self type annotation and, since I know what I&rsquo;m doing,
I don&rsquo;t need the self-recursive type either&rdquo;. Well you may be right but I&rsquo;d have two objections:</p>

<ol>
<li><p>Generally you are not the only one working on a project and, anyway, a good rule of thumb is to design your
software as if you&rsquo;re designing a public API. In this case you want to be sure no one will use your API in the wrong way.</p></li>
<li><p>Compilers are implemented by smart guys, generally. Having the compiler help by your side is
always a good thing in my humble opinion.</p></li>
</ol>


<p>Are there alternatives to this type of problems? Yes indeed, <em>Type Classes</em>, which is by the way the option I prefer.
But this is another story for a future post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Internal DSLs In Scala]]></title>
    <link href="http://www.alessandrolacava.com/blog/introduction-to-internal-dsls-in-scala/"/>
    <updated>2015-03-26T09:41:48+01:00</updated>
    <id>http://www.alessandrolacava.com/blog/introduction-to-internal-dsls-in-scala</id>
    <content type="html"><![CDATA[<p>My introductory article on developing an internal DSL in Scala for currency-related operations
on <a href="http://www.devx.com/enterprise/introduction-to-internal-dsls-in-scala.html">DevX</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Functional Programming In Scala]]></title>
    <link href="http://www.alessandrolacava.com/blog/introduction-to-functional-programming-in-scala/"/>
    <updated>2015-02-28T09:29:30+01:00</updated>
    <id>http://www.alessandrolacava.com/blog/introduction-to-functional-programming-in-scala</id>
    <content type="html"><![CDATA[<p>My introductory article on Functional Programming in Scala
on <a href="http://www.devx.com/enterprise/introduction-to-functional-programming-in-scala.html">DevX</a></p>
]]></content>
  </entry>
  
</feed>
