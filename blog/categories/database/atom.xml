<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Database | Alessandro Lacava]]></title>
  <link href="http://www.alessandrolacava.com/blog/categories/database/atom.xml" rel="self"/>
  <link href="http://www.alessandrolacava.com/"/>
  <updated>2015-06-03T18:50:37+02:00</updated>
  <id>http://www.alessandrolacava.com/</id>
  <author>
    <name><![CDATA[Alessandro Lacava]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Brilliant Client/Server Apps With J2ME, PHP, and MySQL]]></title>
    <link href="http://www.alessandrolacava.com/blog/build-brilliant-clientserver-apps-with-j2me-php-and-mysql/"/>
    <updated>2011-10-26T16:53:41+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/build-brilliant-clientserver-apps-with-j2me-php-and-mysql</id>
    <content type="html"><![CDATA[<h3>In this article you&rsquo;ll see how to make the three technologies work together by developing a simple and useful application that lets you update a multi-user blog and download the latest posts from it.</h3>

<p>Write once, run anywhere. This Java motto seems to hold true even for mobile devices. Indeed, since it was born J2ME has had an ever-increasing impact on mobile development. Some may argue that J2ME is not as portable as other Java technologies, but even so, the result obtained on different mobile devices is, in most cases, still acceptable.</p>

<p>Go to <a href="http://www.devx.com/Java/Article/32069">DevX</a> to read the rest of the article: <strong>Build Brilliant Client/Server Apps with J2ME, PHP, and MySQL</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Performance Differences Between IN and EXISTS]]></title>
    <link href="http://www.alessandrolacava.com/blog/performance-differences-between-in-and-exists/"/>
    <updated>2008-06-04T15:33:24+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/performance-differences-between-in-and-exists</id>
    <content type="html"><![CDATA[<p>Very often I hear people wondering if it&rsquo;s better the <code>EXISTS</code> or the <code>IN</code> operator.
Let&rsquo;s start by saying that the two operators behave differently when <code>NULL</code> values are involved
(see <a href="/blog/2008/06/04/not-in-vs-not-exists-when-null-values-are-involved">this post</a>).</p>

<p>If you are sure that the field used to join the tables does not include <code>NULL</code> values then the <code>IN</code> operator &ldquo;generally&rdquo;
performs better than <code>EXISTS</code>. I say &ldquo;generally&rdquo; because this is not always the case. For example consider the following query:</p>

<pre><code class="sql">SELECT *
FROM table_a a
WHERE a.cd_field NOT IN (SELECT b.cd_field FROM table_b b);
</code></pre>

<p>The previous query is processed more or less as follows:</p>

<pre><code class="sql">SELECT *
FROM table_a a, (SELECT DISTINCT cd_field FROM table_b) b
WHERE a.cd_field != b.cd_field;
</code></pre>

<p>The subquery is evaluated and the duplicates removed from the result.
Then it is joined to the outer table. Now lets analyze the same query using <code>NOT EXISTS</code>:</p>

<pre><code class="sql">SELECT *
FROM table_a a
WHERE NOT EXISTS (SELECT 1 FROM table_b b WHERE a.cd_field = b.cd_field);
</code></pre>

<p>The previous query is processed more or less as follows:</p>

<pre><code class="sql   ">FOR x IN ( SELECT * FROM table_a ) LOOP
  IF ( NOT EXISTS ( SELECT 1 FROM table_b b WHERE x.cd_field = b.cd_field ) THEN
    --output the record
  END IF
END LOOP
</code></pre>

<p>This means that using <code>NOT EXISTS</code> always results in a full scan of the outer table whereas the query which uses <code>NOT IN</code>
can exploit an index on table_a.cd_field. In general <code>NOT IN</code> performs better when the result of the subquery is small
and there&rsquo;s an index on the field used by the join. On the other hand, <code>NOT EXISTS</code> is to prefer when the subquery has
many rows, the outer query is relatively small and there&rsquo;s an index on the field used to join the two tables.
In this latter case the cost of removing duplicates (<code>DISTINCT</code>) could be greater than the cost of the full scan of the outer table.</p>

<p>Of course this is a very general guideline, you should always conduct some test using indexes and so on to figure out
which method to use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NOT IN vs. NOT EXISTS When NULL Values Are Involved]]></title>
    <link href="http://www.alessandrolacava.com/blog/not-in-vs-not-exists-when-null-values-are-involved/"/>
    <updated>2008-06-04T15:24:09+02:00</updated>
    <id>http://www.alessandrolacava.com/blog/not-in-vs-not-exists-when-null-values-are-involved</id>
    <content type="html"><![CDATA[<p><code>NOT IN</code> does not behave as you would expect when <code>NULL</code> values are involved.
Suppose you have the following tables:</p>

<table>
  <tr >
    <td style="color: #696969">CD_FIELD</td>
    <td style="color: #696969">DS_FIELD</td>
  </tr>
  <tr >
    <td>1</td>
    <td>ALPHA</td>
  </tr>
  <tr>
    <td>2</td>
    <td>BETA</td>
  </tr>
</table>


<p><strong>TABLE_A</strong></p>

<table>
  <tr >
    <td style="color: #696969">CD_FIELD</td>
    <td style="color: #696969">DS_FIELD</td>
  </tr>
  <tr >
    <td>1</td>
    <td>GAMMA</td>
  </tr>
  <tr>
    <td>NULL</td>
    <td>DELTA</td>
  </tr>
</table>


<p><strong>TABLE_B</strong></p>

<p>Now try the following query:</p>

<pre><code class="sql  ">SELECT *
FROM table_a a
WHERE a.cd_field NOT IN (SELECT b.cd_field FROM table_b b);
</code></pre>

<p>Does the previous query return any row? The answer is NO it doesn&rsquo;t, even if there is a value (2) in table_a.cd_field
which is not present in table_b.cd_field.</p>

<p>I think this is because <code>NOT IN</code> internally uses the inequality operator.
You should never use the equality or inequality operators with <code>NULL</code>, but <code>IS NULL</code> and <code>IS NOT NULL</code>, respectively.
For this reason, in SQL, <code>NULL</code> is not equal to <code>NULL</code>.
If you don&rsquo;t believe me then try the following query:</p>

<pre><code class="sql   ">SELECT 'test' c
FROM dual
WHERE NULL = NULL;
</code></pre>

<p>It returns 0 rows.</p>

<p>So how can you work this out? Enter the <code>EXISTS</code> (and <code>NOT EXISTS</code>) operator.</p>

<p>Try the following query:</p>

<pre><code class="sql    ">SELECT *
FROM table_a a
WHERE NOT EXISTS (SELECT 1 FROM table_b b WHERE a.cd_field = b.cd_field);
</code></pre>

<p>The previous query returns 1 row, that is what you would expect since there is a row in table_a with cd_field = 2
which is not present in table_b.cd_field.</p>

<p>From now on beware of using <code>NOT IN</code> and <code>IN</code> when <code>NULL</code> values are involved.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get the Number of Columns In a ResultSet In Java]]></title>
    <link href="http://www.alessandrolacava.com/blog/how-to-get-the-number-of-columns-in-a-resultset-in-java/"/>
    <updated>2007-12-12T11:32:31+01:00</updated>
    <id>http://www.alessandrolacava.com/blog/how-to-get-the-number-of-columns-in-a-resultset-in-java</id>
    <content type="html"><![CDATA[<p>In Java it is possible to retrieve the number of columns of a <code>ResultSet</code> dinamically, thanks to the <code>ResultSetMetaData</code>
class. Here&rsquo;s an example:</p>

<pre><code class="java  ">// Here you get the conn object. E.g.:
// Connection conn = DriverManager.getConnection(...);

Statement st = conn.createStatement();
ResultSet rs = st.executeQuery("SELECT * FROM your_table");
ResultSetMetaData rsmd = rs.getMetaData();
int numCols = rsmd.getColumnCount();
System.out.println("Number of columns in your_table: " + numCols);
</code></pre>

<p>The previous code retrieves and displays the number of columns of <code>your_table</code>.</p>
]]></content>
  </entry>
  
</feed>
